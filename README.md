# python-cryptoography-suite
A cryptographic suite includes sets of cryptographic tools for securing a communication. This includes a secure way of exchanging public keys for a given assymmetric crypto system. Exchanging public keys should be securely done through trusted authorities' public certificates. All this step is included in this implementation. The signatures of the certificates are done using RSA and user and system parameter certificates are verified using cryptograhy library RSA verify functionality. The user certificates identify the certain users that some one can communicate in the system. System parameter certificates make accessible the publicly available properties of the elgamal public key crypto system: including large prime number p and a primitive element alpha that is between 1 and p-1. By reading through the public key of users and system parameters, the system can use elgmal crypto system by repeatedly applying the diffie hellman key exchange. This is used to encode a 32 bytes AES key between communicators. The elgamal encryption system works by choosing a random number for each byte and computing a shared secret using the random integer as a private key. The shared secret and public key are all stored to the encrypted file. For decrypting the process is reversed by computing the shared secret and euclidean inverse with in a mulltiplicative group. The implementation of the elgamal can be found in the elgamal/encrypt_gamal.py and elgamal/decrypt_gamal.py files.

The Quantum safe key encapsulation mechanisms are also implemented using the liboqs python library. The problems used in the quantum safe methods are from what is known quantum safe, this can not be said for the discrete logarithm problem and prime factoring problems of the RSA public key crypto system. 

Additional implementation included the implementation of the Cipher Block Chaining mode of AES which is known to be more secure and is useful in implementing hash algorithms. The AES stand alone program can befound in the AES folder. The CBC encryption generates a random nonce and 80 byte headers to work with different file types and sizes. This algorithm works by taking 16 bytes at a time by taking exclusive or of the previous cipher with the current plaintext and encrypting the blocks of bytes using the ECB mode of the cryptography library. Image is included below to show the steps for implementation of the AES CBC mode. 


![CBCimage](https://github.com/user-attachments/assets/cd6149ca-9335-49a4-8b62-4aff3a27db72)

This step is reversed for the decryption step to generate the correct file name, type, and size. To check the implementation of the CBC encryption and decryption check the folder AES/cbc_module/encrypt_cbc.py and AES/cbc_module/decrypt_cbc.py. 
